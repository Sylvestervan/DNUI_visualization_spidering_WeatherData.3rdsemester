websites:
https://www.youtube.com/watch?v=9P5MY_2i7K8
https://www.youtube.com/watch?v=cta1yCb3vA8
https://github.com/sammyfung/hk0weather
https://www.youtube.com/watch?v=baqxBO4PhI8 Weather Prediction With Python And Machine Learning [W/Code] Dataquest
https://www.ceicdata.com/zh-hans
https://www.noaa.gov/
https://www.worldweatheronline.com/
https://en.wikipedia.org/wiki/Curve_fitting
https://worldclim.org/data/worldclim21.html
https://open-meteo.com/en/docs/historical-weather-api
https://docs.anaconda.com/anaconda/install/mac-os/





how to run?
>>> scrapy crawl qiqihar_weather_history -a start_date=yyyy-mm-dd -a end_date=yyyy-mm-dd \n
-a output_path=<your_path_here> <--nolog>

>>> python Automatic_Crawler_api.py

>>> weather_data_collections/Collection_of_API/<Nation>/<Nation>_weather_daily.jsonl
>>> weather_data_collections/Collection_of_API/<Nation>/<Nation>_weather_hourly.jsonl
>>> weather_data_collections/Collection_of_Spider/<Nation>/<Nation>_weather_daily.jsonl
>>> weather_data_collections/Collection_of_Spider/<Nation>/<Nation>_weather_hourly.jsonl

pip install streamlit

streamlit run <ones_visualized_file_name>.py


### 傅里叶变换的数学基础

傅里叶变换是一种数学技术，用于将时间域信号转换为频域信号，从而揭示信号中的周期性成分。其离散形式（DFT）定义如下：

\[ X[k] = \sum_{n=0}^{N-1} x[n] \cdot e^{-j2\pi kn/N} \]

其中：
- \( x[n] \) 表示原始时间域信号。
- \( X[k] \) 表示频域信号。
- \( N \) 是信号的长度。
- \( n \) 和 \( k \) 分别是时间和频率索引。
- \( j \) 是虚数单位。

逆傅里叶变换（IDFT）用于将频域信号转换回时间域信号：

\[ x[n] = \frac{1}{N} \sum_{k=0}^{N-1} X[k] \cdot e^{j2\pi kn/N} \]

### 实际应用

傅里叶变换在许多领域都有广泛应用，包括：
1. **信号处理**：用于滤波、频谱分析和信号去噪。
2. **图像处理**：用于图像压缩、边缘检测和图像增强。
3. **音频处理**：用于音频压缩、噪声消除和语音识别。
4. **天气分析**：用于分析气候数据中的周期性成分，如季节变化和长期趋势。

### 图表分析

#### 第一张图：西欧和北欧城市的温度数据傅里叶变换比较

这张图展示了斯德哥尔摩、奥斯陆、圣彼得堡、赫尔辛基、雷克雅未克和卑尔根这些城市的温度数据的傅里叶变换结果。

- **零频率成分**：所有城市在零频率处都有一个显著的峰值，这表示温度数据的平均值。这是预期的，因为气温数据具有显著的直流分量。
- **低频成分**：在0.01以下的频率范围内，有一些显著的峰值。这些低频成分表示年周期或季节性变化。
- **对数坐标**：使用对数坐标展示频域信号的幅度，使得较小的频率成分也能够被清晰地观察到。

这张图的意义在于，它揭示了不同城市的气温数据中存在的周期性变化。这些变化可能与当地的气候模式和地理位置有关。例如，北欧城市可能具有更显著的季节性变化。

#### 第二张图：中国城市的温度数据傅里叶变换比较

这张图展示了北京、大连、上海和威海这些中国城市的温度数据的傅里叶变换结果。

- **零频率成分**：同样，这些城市在零频率处也有显著的峰值，表示温度数据的平均值。
- **低频成分**：在0.01以下的频率范围内，有一些显著的峰值，表示年周期或季节性变化。
- **对数坐标**：使用对数坐标展示频域信号的幅度，使得较小的频率成分也能够被清晰地观察到。

这张图的意义在于，它展示了中国不同城市的气温数据中的周期性变化。通过比较这些城市的傅里叶变换结果，可以更好地理解这些城市的气候模式和差异。

### 总结

通过傅里叶变换，我们能够揭示温度数据中的周期性变化。这些变化可以帮助我们理解不同地区的气候模式，并为气候研究和预测提供重要的参考。

- **西欧和北欧城市**展示了显著的季节性变化，可能与这些地区的气候模式和地理位置有关。
- **中国城市**展示了类似的季节性变化，但具体的频率成分和幅度可能有所不同，反映了不同地区的气候特征。

傅里叶变换是一种强大的工具，能够帮助我们从时间域信号中提取有价值的频域信息，为各种实际应用提供支持。








custom_settings = {
        'FEED_FORMAT': 'jsonlines',
        'FEED_URI': 'qiqihar_weather_hourly.jsonl',
        'FEED_EXPORT_ENCODING': 'utf-8',
    }
self.output_dir = 'Submission/main/weather_data_collections/Collection_of_Spider/cn'
        self.start_urls = [f"https://www.worldweatheronline.com/weihai-weather-history/heilongjiang/cn.aspx"]
        self.custom_settings = {
            'FEED_FORMAT': 'jsonlines',
            'FEED_URI': f'{self.output_dir}/weihai_daily.jsonl',
            'FEED_EXPORT_ENCODING': 'utf-8',
        }


2024-07-13 23:51
当然，还有很多其他包含高级数学公式的可视化方案，可以帮助揭示数据中的复杂关系，并提供深刻的见解。以下是几个可以考虑的高级可视化方案及其相关数学背景：

### 1. **多元线性回归（Multiple Linear Regression）**
多元线性回归用于研究多个自变量对因变量的影响，公式如下：

\[ y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \ldots + \beta_n x_n + \epsilon \]

- **研究内容**: 研究多个气候变量（如温度、降水量、湿度等）对某一因变量（如作物产量）的综合影响。
- **可视化方案**: 使用三维散点图和回归平面图展示自变量和因变量的关系。

```python
import statsmodels.api as sm
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

# 生成示例数据
data = {
    'Temperature': [15, 16, 15, 16, 15, 16, 15, 16, 15, 16],
    'Precipitation': [200, 190, 195, 180, 205, 200, 195, 180, 185, 190],
    'CropYield': [3.5, 3.2, 3.3, 3.1, 3.4, 3.3, 3.4, 3.1, 3.2, 3.3]
}
df = pd.DataFrame(data)

# 进行多元线性回归
X = df[['Temperature', 'Precipitation']]
y = df['CropYield']
X = sm.add_constant(X)
model = sm.OLS(y, X).fit()

# 可视化结果
sns.pairplot(df)
plt.suptitle('Multiple Linear Regression', y=1.02)
plt.show()
```

### 2. **时间序列分析（Time Series Analysis）**
时间序列分析用于研究数据随时间的变化趋势和周期性，常用模型包括ARIMA、SARIMA等。

\[ Y_t = \alpha + \beta t + \gamma \sin(\omega t + \phi) + \epsilon_t \]

- **研究内容**: 分析气候数据（如温度、降水量）的季节性和长期趋势。
- **可视化方案**: 使用时间序列图、ACF（自相关函数）图和PACF（偏自相关函数）图展示数据的周期性和趋势。

```python
import matplotlib.pyplot as plt
import pandas as pd
import statsmodels.api as sm

# 生成示例时间序列数据
date_rng = pd.date_range(start='1/1/2020', end='1/1/2021', freq='M')
df = pd.DataFrame(date_rng, columns=['date'])
df['data'] = [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]

# 进行时间序列分析
df.set_index('date', inplace=True)
decomposition = sm.tsa.seasonal_decompose(df['data'], model='additive')
fig = decomposition.plot()
plt.show()
```

### 3. **主成分分析（Principal Component Analysis, PCA）**
PCA用于降维和揭示数据的内在结构，公式如下：

\[ Z = XW \]

其中，\( X \) 是原始数据矩阵，\( W \) 是特征向量矩阵，\( Z \) 是降维后的数据矩阵。

- **研究内容**: 通过降维分析，找出气候数据的主要影响因素。
- **可视化方案**: 使用散点图和二维或三维PCA图展示降维后的数据。

```python
from sklearn.decomposition import PCA
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

# 生成示例数据
data = {
    'Temperature': [15, 16, 15, 16, 15, 16, 15, 16, 15, 16],
    'Precipitation': [200, 190, 195, 180, 205, 200, 195, 180, 185, 190],
    'Humidity': [30, 40, 35, 45, 50, 55, 60, 65, 70, 75]
}
df = pd.DataFrame(data)

# 进行PCA
pca = PCA(n_components=2)
principalComponents = pca.fit_transform(df)
principalDf = pd.DataFrame(data=principalComponents, columns=['principal component 1', 'principal component 2'])

# 可视化PCA结果
plt.figure(figsize=(8,6))
sns.scatterplot(x='principal component 1', y='principal component 2', data=principalDf)
plt.title('PCA of Climate Data')
plt.show()
```

### 4. **聚类分析（Clustering Analysis）**
聚类分析用于将数据分成多个组别（簇），公式如下：

\[ J = \sum_{i=1}^{k} \sum_{x \in C_i} \|x - \mu_i\|^2 \]

其中，\( k \) 是簇的数量，\( C_i \) 是第 \( i \) 个簇，\( \mu_i \) 是第 \( i \) 个簇的质心。

- **研究内容**: 将气候数据分成不同的气候类型。
- **可视化方案**: 使用散点图和簇间距离图展示聚类结果。

```python
from sklearn.cluster import KMeans
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

# 生成示例数据
data = {
    'Temperature': [15, 16, 15, 16, 15, 16, 15, 16, 15, 16],
    'Precipitation': [200, 190, 195, 180, 205, 200, 195, 180, 185, 190]
}
df = pd.DataFrame(data)

# 进行K-means聚类
kmeans = KMeans(n_clusters=2)
df['Cluster'] = kmeans.fit_predict(df)

# 可视化聚类结果
plt.figure(figsize=(8,6))
sns.scatterplot(x='Temperature', y='Precipitation', hue='Cluster', data=df, palette='viridis')
plt.title('K-means Clustering of Climate Data')
plt.show()
```

这些方法通过使用复杂的数学模型和算法，能够深入分析和可视化气候数据中的潜在关系和模式。每种方法都有其独特的应用场景，可以根据具体的研究问题选择合适的方法进行分析和可视化。


